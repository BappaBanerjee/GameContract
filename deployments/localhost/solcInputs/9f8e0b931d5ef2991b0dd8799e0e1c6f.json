{
  "language": "Solidity",
  "sources": {
    "contracts/Game.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./UserRegistration.sol\";\r\nimport \"./Practice.sol\";\r\n\r\ncontract Game is UserRegistration, Practice {\r\n    //custom error\r\n    error Game_Not_Authorised(); //when non user tries to access\r\n    error Game__Is_Busy(); //throw error if user try to execute before particular interval\r\n\r\n    uint256 private constant TIME_LOCK_IN_SEC = 60; //Time lock user for certer amount of time for further execution\r\n    mapping(address => uint256) public waiting_time; //tracking user waiting time\r\n\r\n    //modifiers\r\n    modifier isBusy() {\r\n        if (block.timestamp < waiting_time[msg.sender]) revert Game__Is_Busy();\r\n        _;\r\n    }\r\n\r\n    /*\r\n        @dev register a user to the game. It call the functio _register from the userRegistration contract\r\n        @param user role, 0 for batsman and 1 for bowler and username of the user\r\n        requirement :- \r\n            role should be a 0 for batsman and 1 for bowler \r\n            username can be string\r\n        @event : emit the event userRegistered()\r\n    */\r\n    function register(Role _role, string memory _username) public {\r\n        _register(_role, _username);\r\n    }\r\n\r\n    /*\r\n        @dev function to unregister a user\r\n        requirements :\r\n            **should be a already a user\r\n        @event : emit the event userUnregisterd()\r\n    */\r\n    function unRegister() public {\r\n        _unRegister();\r\n    }\r\n\r\n    /*\r\n        @dev skill up the particular shots\r\n        @param give the shot number \r\n            1 for coverdrive\r\n            2 for strightdrive\r\n            3 for pull shot\r\n            4 for squarecut\r\n        \r\n        requirements : \r\n            *has to be the batsman role\r\n            *shot number must be in range \r\n            *waiting time must be less than block.timestamp or 0\r\n    */\r\n    function practiceShots(uint256 _shot) public isBusy {\r\n        if (_getPlayerRole(msg.sender) != Role.Batsman)\r\n            revert Game_Not_Authorised();\r\n        require(_shot > 0 && _shot < 5, \"Invalid selection\");\r\n        waiting_time[msg.sender] = block.timestamp + TIME_LOCK_IN_SEC;\r\n        if (_shot == 1) {\r\n            _practiceCoverDrive();\r\n        } else if (_shot == 2) {\r\n            _practiceStraightDrive();\r\n        } else if (_shot == 3) {\r\n            _practicePull();\r\n        } else if (_shot == 4) {\r\n            _practiceSquareCut();\r\n        }\r\n    }\r\n\r\n    /*\r\n        @dev skill up the particular shots\r\n        @param give the shot number \r\n            1 for yocker\r\n            2 for strightdrive\r\n            3 for pull shot\r\n            4 for squarecut\r\n        requirements : \r\n            *has to be the batsman role\r\n            *shot number must be in range \r\n            *waiting time must be less than block.timestamp or 0\r\n    */\r\n    function practiceBowling(uint256 _skill) public isBusy {\r\n        if (_getPlayerRole(msg.sender) != Role.Bowler)\r\n            revert Game_Not_Authorised();\r\n        require(_skill > 0 && _skill < 4, \"Invalid selection\");\r\n        waiting_time[msg.sender] = block.timestamp + TIME_LOCK_IN_SEC;\r\n        if (_skill == 1) {\r\n            _practiceYocker();\r\n        } else if (_skill == 2) {\r\n            _practiceBouncer();\r\n        } else if (_skill == 3) {\r\n            _practiceLengthBall();\r\n        }\r\n    }\r\n\r\n    event onDeposit(string _token, uint256 _quantity, address _from);\r\n    event onWithdraw(string _token, uint256 _quantity, address _to);\r\n\r\n    function deposit(uint256 _quantity) public {\r\n        require(_quantity > 0, \"quantity must be greater than 0\");\r\n        emit onDeposit(\"Ball\", _quantity, msg.sender);\r\n    }\r\n\r\n    function withdraw(uint256 _quantity, address _address) public {\r\n        require(_quantity > 0, \"quantity must be greater than 0\");\r\n        emit onDeposit(\"Ball\", _quantity, _address);\r\n    }\r\n}\r\n"
    },
    "contracts/Practice.sol": {
      "content": "//SPDX-License-Identifier:MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract Practice {\r\n    //custom error\r\n    error skillup_max_limit_reached(uint limit); //throw error if the max limit of the skill reached\r\n\r\n    //variables\r\n    uint private constant MAX_SKILL_POINT = 10; //max limit of the skills\r\n\r\n    //data structure for the batting shots\r\n    struct Shots {\r\n        uint coverDrive;\r\n        uint straightDrive;\r\n        uint pull;\r\n        uint squareCut;\r\n    }\r\n    //data structure for the bowlig skills\r\n    struct Bowl {\r\n        uint yocker;\r\n        uint bouncer;\r\n        uint lengthBall;\r\n    }\r\n\r\n    mapping(address => Shots) public BattingSkill;\r\n    mapping(address => Bowl) public BowlingSkill;\r\n\r\n    /*\r\n        @dev function to check if the skill value reached the threshold value\r\n        @param the value of the skill\r\n        requiremt :\r\n            if the value is greater than the maximum value (MAX_SKILL_POINT) then it will revert the execution of the function\r\n    */\r\n    function checkLimit(uint value) private pure {\r\n        if (value >= MAX_SKILL_POINT) revert skillup_max_limit_reached(value);\r\n    }\r\n\r\n    //Batting shots\r\n    /*\r\n        @dev functions to level up individual batting shots skills by 1\r\n    */\r\n    function _practiceCoverDrive() internal {\r\n        Shots memory skill = BattingSkill[msg.sender];\r\n        checkLimit(skill.coverDrive);\r\n        skill.coverDrive += 1;\r\n        BattingSkill[msg.sender] = skill;\r\n    }\r\n\r\n    function _practiceStraightDrive() internal {\r\n        Shots memory skill = BattingSkill[msg.sender];\r\n        checkLimit(skill.straightDrive);\r\n        skill.straightDrive += 1;\r\n        BattingSkill[msg.sender] = skill;\r\n    }\r\n\r\n    function _practicePull() internal {\r\n        Shots memory skill = BattingSkill[msg.sender];\r\n        checkLimit(skill.pull);\r\n        skill.pull += 1;\r\n        BattingSkill[msg.sender] = skill;\r\n    }\r\n\r\n    function _practiceSquareCut() internal {\r\n        Shots memory skill = BattingSkill[msg.sender];\r\n        checkLimit(skill.squareCut);\r\n        skill.squareCut += 1;\r\n        BattingSkill[msg.sender] = skill;\r\n    }\r\n\r\n    //Bowler _practice\r\n    /*\r\n        @dev function to level up individual bowling skills by 1\r\n    */\r\n    function _practiceYocker() internal {\r\n        Bowl memory skill = BowlingSkill[msg.sender];\r\n        checkLimit(skill.yocker);\r\n        skill.yocker += 1;\r\n        BowlingSkill[msg.sender] = skill;\r\n    }\r\n\r\n    function _practiceBouncer() internal {\r\n        Bowl memory skill = BowlingSkill[msg.sender];\r\n        checkLimit(skill.bouncer);\r\n        skill.bouncer += 1;\r\n        BowlingSkill[msg.sender] = skill;\r\n    }\r\n\r\n    function _practiceLengthBall() internal {\r\n        Bowl memory skill = BowlingSkill[msg.sender];\r\n        checkLimit(skill.lengthBall);\r\n        skill.lengthBall += 1;\r\n        BowlingSkill[msg.sender] = skill;\r\n    }\r\n}\r\n"
    },
    "contracts/UserRegistration.sol": {
      "content": "//SPDX-License-Identifier:MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract UserRegistration{\r\n    //custom error \r\n    error userRegistration__already_a_player();//throw error if the user is already a user\r\n    error Not_a_player();//throw error if sender if not a player\r\n\r\n    //variables\r\n    uint private userId = 1000;//count for the user ID's\r\n    enum Role{//options for the role, the user can choose\r\n        Batsman,\r\n        Bowler\r\n    }\r\n    //data structure for the user\r\n    struct Player{\r\n        Role role;//batsman or bowler\r\n        string username;//username of the user\r\n        uint Id;//Id of the user\r\n    }\r\n    mapping(address=> Player) private playerDetails;\r\n    mapping(address=> bool) private isPlayer;\r\n\r\n    // all events declared here\r\n    event userRegistered(Role role, string username, uint userId);\r\n    event userUnregisterd(address userAddress);\r\n\r\n    //all function starts from here \r\n    /*\r\n        @dev function to register the user \r\n        @param role of the player and username of the player\r\n        requirement :- \r\n            role should be a 0 for batsman and 1 for bowler \r\n            username can be string\r\n        @event : emit the event userRegistered()\r\n    */\r\n    function _register(Role _role, string memory _username) internal{\r\n        if(isPlayer[msg.sender]) revert userRegistration__already_a_player();\r\n        playerDetails[msg.sender] = Player(\r\n            _role,\r\n            _username,\r\n            userId\r\n        );\r\n        isPlayer[msg.sender] = true;\r\n        ++userId;\r\n        emit userRegistered(_role , _username , userId);\r\n    }\r\n\r\n    /*\r\n        @dev function to unregister a user\r\n        requirements :\r\n            **should be a already a user\r\n        @event : emit the event userUnregisterd()\r\n    */\r\n    function _unRegister() internal{\r\n        if(!isPlayer[msg.sender]) revert Not_a_player();\r\n        isPlayer[msg.sender] = false;\r\n        delete playerDetails[msg.sender];\r\n        emit userUnregisterd(msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev return the details of the player if registered\r\n    */\r\n    function _getPlayerDetails() public view returns(Player memory) {\r\n        return playerDetails[msg.sender];\r\n    }\r\n\r\n    /*\r\n        @dev return if the player is listed or not\r\n        @param address of the user\r\n    */\r\n    function _isPlayer(address _address) public view returns(bool){\r\n        return isPlayer[_address];\r\n    }\r\n    /*\r\n        @dev returns the role of the player, mainly 0 for batsman and 1 for bowler\r\n        @param address of the user\r\n    */\r\n    function _getPlayerRole(address _address) public view returns(Role){\r\n        require(_isPlayer(_address) , \"Not a player\");\r\n        return playerDetails[_address].role;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}